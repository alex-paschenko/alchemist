<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Alchemist</title>
  <link rel="stylesheet" href="./res/main.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-light.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/typescript.min.js"></script>
</head>
<body>
  <div class="flex-container">
    <img style="width: 300px; height: 300px; margin:25px; object-fit: cover;" src="./res/alchemist.png" alt="Alchemist image" />
    <div style="flex:1">
      <h2>Alchemist</h2>
      <p>A fast, lightweight, zero-dependency ts/js package designed to restore the rightful throne to the most powerful
        and elegant aspect of OOP: multiple inheritance.</p>
      <p>Simple, flexible, and ready to roll!</p>
      <nav>
        <h4>Table of content</h4>
        <ul>
          <li><a href="#what-is-included">What’s included and what's not included</a></li>
          <li><a href="#motivation">Motivation</a></li>
          <li><a href="#simple-example">Simple example</a></li>
          <li><a href="#recipes">Recipes</a></li>
        </ul>
      </nav>
    </div>
  </div>

  <section id="what-is-included">
    <div>
      <h3>What’s included:</h3>
      <ul style="list-style-image: url('res/green-check-mark-16.png');">
        <li>Full built-in classes support:
          <ul style="list-style-image: none;">
            <li>The proper functioning is guaranteed not only for custom classes but also for <strong>all</strong> built-in JavaScript
              classes and the classes that extend them (including those with internal slots - like as
              <span class="inline-code language-javascript">Date</span>,
              <span class="inline-code language-javascript">TypedArray</span>,
              <span class="inline-code language-javascript">Map</span> etc.).</li>
          </ul>
        </li>
        <li>Copying instance methods and properties:
          <ul style="list-style-image: none;">
            <li>Inside the Result constructor, instances of all base classes are created, and their properties are assigned to the final object.</li>
          </ul>
        </li>
        <li>Copying static methods and properties:
          <ul style="list-style-image: none;">
            <li>All static properties and methods from the base classes are present in the Result class.</li>
          </ul>
        </li>
        <li>instanceof support:
          <ul style="list-style-image: none;">
            <li>If you need <span class="inline-code language-javascript">instanceof</span> support, you can enable it
              (except for built-in JavaScript classes like <span class="inline-code language-javascript">Map</span>,
              <span class="inline-code language-javascript">Array</span>, <span class="inline-code language-javascript">Promise</span>,
              etc. Even alchemy can't help here!).</li>
          </ul>
        </li>
        <li>Compatibility with getters/setters:
          <ul style="list-style-image: none;">
            <li>The Alchemist carefully transfers all getters and setters from the original classes into the resulting class.</li>
          </ul>
        </li>
      </ul>
      <h3>What’s not included yet:</h3>
      <ul style="list-style-image: url('res/red-cross-16.png');">
        <li>Support for decorators and other metadata:
          <ul style="list-style-image: none;">
            <li>Right now, this functionality works partially, but stable and full support isn't guaranteed.</li>
          </ul>
        </li>
      </ul>
    </div>
  </section>

  <section id="motivation">
    
      <div class="spoiler">
        <div class="spoiler-header">
          <h3>Motivation</h3>
          <div>
            <span class="show-button">Show</span>
            <span class="hide-button" style="display: none;">Hide</span>
          </div>
        </div>
        <div class="spoiler-content">
          <p>Multiple inheritance is the most powerful pattern in object-oriented programming (OOP).</p>
        <p>Of course, like any other weapon, it can be dangerous. Sure, you could accidentally shoot yourself with it.</p>
        <p>That’s why the creators of many modern programming languages decided, “Hey, let’s take away this dangerous toy
          from the user, and just to be safe, let’s strap them into a straightjacket!”</p>
        <p>Guys, that doesn’t work! Single inheritance — the one thing users (for now) still have — often leads to ugly
          application architecture. It turns what could’ve been a reasonable representation of reality using classes
          into the nightmare of a binge-drinking stranger.</p>
        <p>&nbsp;</p>
        <p>If I met the owner of an airline in a flophouse, and he offered me to create an app for his company, the
          conversation might go like this:</p>
        <p>&nbsp;</p>
        <p><strong>Him:</strong> Hey, you seem like a smart person. How about writing an app for my airline?</p>
        <p><strong>Me:</strong> Well, that’s an unexpected offer, but it sounds interesting. What kind of app do you need?</p>
        <p><strong>Him:</strong> I want something better than what my competitors have. It should be simple, user-friendly,
          and, of course, cool!</p>
        <p>&nbsp;</p>
        <p>In the morning, hungover, I remember this conversation and start brainstorming the architecture.</p>
        <p>Here’s how we can describe the airplane crew for our app:</p>
        <ul>
          <li>
            <strong>Captain (First Pilot)</strong>
            <ul><li>
              Duties: Scold passengers and turn on autopilot.<br/>
              (You know, the serious stuff. Someone’s gotta do it!).
            </li></ul>
          </li>
          <li>
            <strong>Co-Pilot</strong>
            <ul><li>
              Skills: Play music and use GPS.<br>
              (Why GPS? Well, at least it’s handy for quickly finding a pub in any city!)
            </li></ul>
          <li>
            <strong>Flight Engineer</strong>
            <ul><li>
              Talents: Tell jokes and wake up the rest of the crew after landing.<br>
              (Because old jokes won’t laugh at themselves, right?)
            </li></ul>
          </li>
        </ul>
        <p>Describing this with classes is easier than taking candy from a baby:</p>
        
      <div class="code-block">
        <pre class="ts active"><code class="language-typescript">class Captain {
  scoldPassengers() { return &#x27;This? This is me being polite. Wait till I actually start!&#x27;; };
  turnOnAutopilot() { return &#x27;Does anyone know where the damn button is?&#x27;; };
}

class CoPilot {
  playMusic() { return &#x27;Oh, come on, my singing&#x2019;s fine.&#x27;; };
  useGPS() { return &#x27;The GPS isn&#x2019;t working: I left my phone somewhere.&#x27;; };
}

class FlightEngineer {
  tellJokes() { return &#x27;So, an Irishman walks into a pub&#x2026;&#x27;; };
  wakeUpCrew() { return &#x27;First, someone needs to wake me up.&#x27;; };
}
</code></pre>
      </div>
    
        <p>"Perfect!" says the company owner after looking at the result of our work.
          "Just one small comment. You see, my airline isn’t exactly in the top ten
          global leaders (by the way, will $5 be enough for your work?). So, not all
          flights have three crew members. For some routes, I hire just one person
          who can handle all the crew’s duties."</p>
        <p>And that’s when we realize our app is heading for a plane crash! Implementing such a simple and
          natural thing without multiple inheritance... damn, it’d be easier to explain
          to my mom why I’m still single!</p>
        <p>But we’re not here to talk about the problems. We’re here to talk about the solution.</p>
        <p>Fortunately, neither our earnings nor our reputation are at risk: the Alchemist package brings simplicity
          back to these simple things:</p>
        </div>
      </div>
    
  </section>

  <section id="simple-example">
    <div>
      <h3>Simple example</h3>
      
      <div class="code-block">
        <pre class="ts active"><code class="language-typescript">import { alchemize } from &#x27;@lenka/alchemist&#x27;;

class Captain {
  scoldPassengers() { return &#x27;This? This is me being polite. Wait till I actually start!&#x27;; };
  turnOnAutopilot() { return &#x27;Does anyone know where the damn button is?&#x27;; };
}

class CoPilot {
  playMusic() { return &#x27;Oh, come on, my singing&#x2019;s fine.&#x27;; };
  useGPS() { return &#x27;The GPS isn&#x2019;t working: I left my phone somewhere.&#x27;; };
}

class FlightEngineer {
  tellJokes() { return &#x27;So, an Irishman walks into a pub&#x2026;&#x27;; };
  wakeUpCrew() { return &#x27;First, someone needs to wake me up.&#x27;; };
}

const SuperHero = alchemize(Captain, CoPilot, FlightEngineer);

const superman = new SuperHero();

superman.scoldPassengers();
superman.playMusic();
superman.tellJokes();
// ...
</code></pre>
      </div>
    
      <p>And that’s it!</p>
      <p>So far, nothing too complicated, right?</p>
      <p>But there’s still something unclear.</p>
      <p><span class="inline-code language-javascript">alchemize()</span> is supposed to combine several
        classes into one. But <span class="bold-italic">how</span> is it supposed to do that?</p>
      <p>For example, the original classes take some parameters in their constructors:</p>
      
      <div class="code-block">
        <div class="code-buttons">
          <button class="active" data-target="ts">TS</button>
          <button data-target="js">JS</button>
        </div>
        <pre class="ts active"><code class="language-typescript">class Volume {
  constructor(private length: number, private width: number, private height: number) {}

  calculateVolume(): number {
    return this.length * this.width * this.height;
  }
}

class Person {
  constructor(private firstName: string, private lastName: string) {}

  get fullName(): string {
    return &#x60;${this.firstName} ${this.lastName}&#x60;;
  }
}</code></pre>
        <pre class="js"><code class="language-javascript">class Volume {
  #length;
  #width;
  #height;

  constructor(length, width, height) {
    this.#length = length;
    this.#width = width;
    this.#height = height;
  }

  calculateVolume() {
    return this.#length * this.#width * this.#height;
  }
}

class Person {
  #firstName;
  #lastName;
  constructor(firstName, lastName) {
    this.#firstName = firstName;
    this.#lastName = lastName;
  }

  get fullName() {
    return &#x60;${this.#firstName} ${this.#lastName}&#x60;;
  }
}</code></pre>
      </div>
    
      <p>Obviously, our combined class should also take all those parameters:</p>
      
      <div class="code-block">
        <pre class="ts active"><code class="language-typescript">const VolumeOfPerson = alchemize(Volume, Person);

const instance = new VolumeOfPerson(25, 18, 38, &#x27;John&#x27;, &#x27;Dow&#x27;);</code></pre>
      </div>
    
      <p>But how will it know what to do with them?</p>
      <p>So, what do we usually do in plain old JavaScript when working with single inheritance?
        In the constructor of the derived class, we call the constructor of the base class (using
        <span class="inline-code language-javascript">super(...)</span>) and pass it some of the arguments
        — the ones it needs for its initialization.</p>
      <p><span class="inline-code language-javascript">alchemize(...)</span> works in a pretty similar way.
        By default, when you create an instance (using
        <span class="inline-code language-javascript">new Combined(...)</span>), it initializes all the input classes
        and passes all the received parameters to each constructor.</p>
      <p>Obviously, this isn’t always the correct behavior.</p>
      <p>This is where recipes come to the rescue, helping us solve this and other challenges.
        Let’s dive right into them!</p>
    </div>
  </section>

  <section id="recipes">
    <div>
      <h3>Recipes</h3>
      <div class="flex-container">
        <div style="max-width: 350px;">
          <img style="width: 300px; height: 300px; margin:25px; object-fit: cover;" src="./res/recipes.png" alt="Recipe image" />
          <p>To create something extraordinary (a panacea, the sorcerer’s stone, or grandma’s apple pie), every
            alchemist needs a recipe.</p>
        </div>
        <div style="flex:1">
          <p>In the <span class="inline-code language-javascript">Alchemist</span> package,
            <span class="inline-code language-javascript">recipe(...)</span> is a function that takes a set of instructions
            and returns an object with a configured <span class="inline-code language-javascript">alchemize(...)</span>
            function:</p>
          
      <div class="code-block">
        <div class="code-buttons">
          <button class="active" data-target="ts">TS</button>
          <button data-target="js">JS</button>
        </div>
        <pre class="ts active"><code class="language-typescript">import { recipe, Recipe } from &#x27;@lenka/alchemist&#x27;;

// For your convenience, Alchemize offers a handy helper
// type called Recipe.
const prescription: Recipe = { instanceOfSupport: true };

class SomeClassA {};
class SomeClassB {};

// You can either chain the call like this...
const CombinedClass =
  recipe(prescription).alchemize(SomeClassA, SomeClassB);

// ...or you can save the result into a variable if you plan
// to reuse the same settings in multiple places and call
// alchemize later:
const tunedAlchemize = recipe(prescription).alchemize;

const TheSameCombinedClass =
  tunedAlchemize(SomeClassA, SomeClassB);

const instance = new CombinedClass(...);</code></pre>
        <pre class="js"><code class="language-javascript">import { recipe } from &#x27;@lenka/alchemist&#x27;;

const prescription = { instanceOfSupport: true };

class SomeClassA {};
class SomeClassB {};

// You can either chain the call like this...
const CombinedClass =
  recipe(prescription).alchemize(SomeClassA, SomeClassB);

// ...or you can save the result into a variable if you plan
// to reuse the same settings in multiple places and call
// alchemize later:
const tunedAlchemize = recipe(prescription).alchemize;

const TheSameCombinedClass =
  tunedAlchemize(SomeClassA, SomeClassB);

const instance = new CombinedClass(...);</code></pre>
      </div>
    
        </div>
      </div>
      <p><span class="inline-code language-typescript">recipe(...)</span> takes a single parameter –
        an object with two optional keys:</p>
      <ul>
        <li><span class="inline-code language-typescript">instanceOfSupport: boolean</span>
          <span class="notes">(default is <span class="inline-code language-typescript">false</span>)</span> –
          set this to true if you need instanceof support for instances of classes created with
          <span class="inline-code language-typescript">alchemize()</span>.
          <ul class="notes">
            <li>Enabling <span class="inline-code language-typescript">instanceOfSupport</span> will slightly
              slow down the execution of <span class="inline-code language-typescript">alchemize()</span>.
              However, it does not affect the runtime performance of the instance created from the class.
            </li>
            <li>
              <img src="res/notes-70x78.png" style="float: left; margin: 0 10px 0 0; width: 20px;">
              Unfortunately, even with <span class="inline-code language-typescript">instanceOfSupport</span>
              enabled, the <span class="inline-code language-typescript">instanceof</span> operator will still return
              <span class="inline-code language-typescript">false</span> for built-in JavaScript classes.
            </li>
          </ul>

          <div>

          </div>
        </li>
        <li style="clear: both;">
          <span class="inline-code language-typescript">passOutParamRules</span> is an array that defines how parameters
            will be distributed across the constructors of the input classes when an instance of the alchemized class is
            created.
          <ul>
            <li>
              If this parameter is missing or an empty array, each input class's constructor will receive all the
              arguments passed during instantiation.
            </li>
            <li>
              <p>If <span class="inline-code language-typescript">passOutParamRules</span> is not an empty array, its
                number of elements must exactly match the number of classes passed as parameters to
                <span class="inline-code language-typescript">alchemize()</span>: the n-th element of
                <span class="inline-code language-typescript">passOutParamRules</span> determines which arguments will
                be passed to the constructor of class provided as the n-th parameter to the
                <span class="inline-code language-typescript">alchemize()</span> function.</p>
              <p>When creating an instance of the combined class, its internal constructor goes through this array from
                left to right, applying the rules one by one.</p>
              <p>Elements of <span class="inline-code language-typescript">passOutParamRules</span> can be:
                <ul>
                  <li><strong>positive integer:</strong> take the first n elements from the input parameter list and
                    pass them to the corresponding class constructor.</li>
                  <li><strong>negative integer:</strong> take the last n elements from the input parameter list and
                    pass them to the corresponding class constructor.</li>
                  <li><strong>0:</strong> do nothing (the corresponding constructor gets no parameters).</li>
                  <li><strong>'...':</strong> This rule is skipped during the initial pass through passOutParamRules.
                    Later, the corresponding constructor receives whatever is left of the input parameter list after
                    all numeric rules have been applied.</li>
                </ul>
              <p>All of this might sound intimidating, but in reality,
                <span class="inline-code language-typescript">passOutParamRules</span> just describes parameter
                splitting in the simplest and most straightforward way:</p>
              
      <div class="code-block">
        <pre class="ts active"><code class="language-typescript">// Let&#x27;s say we want to alchemize five classes and properly
// distribute the parameters among them:
class A {};
class B {};
class C {};
class D {};
class E {};

// That means our passOutParamRules should have five elements.
// For example:
passOutParamRules: [-2, &#x27;...&#x27;, 1, -1, 0];

// Let&#x27;s say we initialize an instance of the alchemized class
// with seven parameters:
const ourMegaInstance =
  new AlchemizedClass(&#x27;a&#x27;, 2, { k: 8}, 10, [9], &#x27;zz&#x27;, 5);

// Internal AlchemizedClass constructor go through the passOutParamRules
// from left to right, applying the rules one by one:
//
// Step 1 - rule &#x22;-2&#x22;:
//   constructor A takes last 2 params (&#x27;zz&#x27; and 5).
//   rest of params after this step: &#x27;a&#x27;, 2, { k: 8}, 10, [9]
// Step 2 - rule &#x27;...&#x27;:
//   this rule is temporarily skipped.
//   rest of params after this step: &#x27;a&#x27;, 2, { k: 8}, 10, [9]
// Step 3 - rule &#x22;1&#x22;:
//   constructor C takes 1 first param (&#x27;a&#x27;).
//   rest of params after this step: 2, { k: 8}, 10, [9]
// Step 4 - rule &#x22;-1&#x22;:
//   constructor D takes 1 last param ([9]).
//   rest of params after this step: 2, { k: 8}, 10
// Step 5 - rule &#x22;0&#x22;:
//   constructor E takes no parameters.
//   rest of params after this step: 2, { k: 8}, 10
// Step 6 - apply postponed &#x27;...&#x27; rule:
//   constructor B takes rest of params (2, { k: 8}, 10)</code></pre>
      </div>
    
              <p>Here's a detailed example that clearly shows
                what, where, when, and how everything is done. Open the spoiler to check it out!</p>
              
      <div class="spoiler">
        <div class="spoiler-header">
          <h3>passOutParamRules usage</h3>
          <div>
            <span class="show-button">Show</span>
            <span class="hide-button" style="display: none;">Hide</span>
          </div>
        </div>
        <div class="spoiler-content">
          <div class="code-block">
        <div class="code-buttons">
          <button class="active" data-target="ts">TS</button>
          <button data-target="js">JS</button>
        </div>
        <pre class="ts active"><code class="language-typescript">import { recipe, Recipe } from &#x27;@lenka/alchemist&#x27;;

/**
 * Let&#x27;s say we need to merge four such classes:
 */

// Class A: takes two arguments
class A {
  constructor(private a: number, private b: number) {}
  sum(): number { return this.a + this.b}
}

// Class B: takes no arguments
class B {
  whereAreYou(): string { return &#x22;I&#x27;m here!&#x22;; }
}

// Class C: takes any number of arguments
class C {
  constructor(...args: number[]) {
    this.args = args;
  }
  max(): number { return Math.max(...this.args); }
  private args: number[];
}

// Class D: takes one argument
class D {
  constructor(private n: number) {}
  plus(b: number): number { return this.n + b }
}

/**
 * We&#x27;re going to alchemize them in this order: A, B, C, D.
 * Alright, let&#x27;s get started!
 */

/**
 * The first thing we need to do is define the parameter distribution
 * rules for the constructors of the original classes.
 * Since the constructor of class C can take any number of arguments,
 * we want to preserve this flexibility for the combined class as well.
 * So, our combined class will be able to accept any number of parameters:
 * const combinedInstance = new Combined(a, b, c, d, ..., n);
 * At the same time:
 * - class A will always receive the first two parameters.
 * - class B won&#x2019;t receive any parameters at all.
 * - class D will get the last parameter.
 * - class C will take everything else in between.
 * So, our rules will look like this:
 */
const passOutParamRules: Recipe[&#x27;passOutParamRules&#x27;] = [2, 0, &#x27;...&#x27;, -1];

/**
 * Next, Let&#x27;s set up a customized alchemize that will create combined
 * classes with this behavior:
 */
const customizedAlchemize = recipe({ passOutParamRules }).alchemize;

/**
 * And let&#x2019;s call it to create our combined class:
 */
const CombinedClass = customizedAlchemize(A, B, C, D);

/**
 * Note: Of course, we could have done all of this in a single step.
 * This directly creates the combined class without needing to
 * store customizedAlchemize separately. However, defining alchemize
 * beforehand can be useful if we plan to reuse the same rules
 * multiple times.
 */
const TheSameCombinedClass = recipe({
  passOutParamRules: [2, 0, &#x27;...&#x27;, -1],
}).alchemize(A, B, C, D);

/**
 * We&#x2019;re all set! Now we can create instances of CombinedClass
 * and see it in action.
 */
const combo = new CombinedClass(10, 11, 12, 13, 14, 15);

console.log(combo.sum());         // 21 (10 + 11)
console.log(combo.whereAreYou()); // I&#x27;m here!
console.log(combo.max());         // 14 (maximum of 12, 13, 14)
console.log(combo.plus(5));       // 20 (15 + 5)
</code></pre>
        <pre class="js"><code class="language-javascript">File not found</code></pre>
      </div>
        </div>
      </div>
    
            </li>
          </ul>

        </li>
      </ul>
    </div>
  </section>

  <script src="./res/script.js"></script>
</body>
</html>
